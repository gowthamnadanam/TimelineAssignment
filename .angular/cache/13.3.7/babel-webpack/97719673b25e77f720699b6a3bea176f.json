{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3, getBsVer } from 'ngx-bootstrap/utils';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\n\nfunction CarouselComponent_ng_container_1_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r8 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 7);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_1_li_2_Template_li_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r8);\n      const i_r6 = restoredCtx.index;\n      const ctx_r7 = i0.ɵɵnextContext(2);\n      return ctx_r7.selectSlide(i_r6);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const slide_r5 = ctx.$implicit;\n    i0.ɵɵclassProp(\"active\", slide_r5.active === true);\n  }\n}\n\nfunction CarouselComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ol\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_1_li_2_Template, 1, 2, \"li\", 6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.indicatorsSlides());\n  }\n}\n\nfunction CarouselComponent_ng_container_2_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 9);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_container_2_button_2_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const i_r11 = restoredCtx.index;\n      const ctx_r12 = i0.ɵɵnextContext(2);\n      return ctx_r12.selectSlide(i_r11);\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const slide_r10 = ctx.$implicit;\n    const i_r11 = ctx.index;\n    const ctx_r9 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"active\", slide_r10.active === true);\n    i0.ɵɵattribute(\"data-bs-target\", \"#\" + ctx_r9.currentId)(\"data-bs-slide-to\", i_r11);\n  }\n}\n\nfunction CarouselComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 5);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_button_2_Template, 1, 4, \"button\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r1.indicatorsSlides());\n  }\n}\n\nfunction CarouselComponent_a_5_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 13);\n    i0.ɵɵtext(1, \"Previous\");\n    i0.ɵɵelementEnd();\n  }\n}\n\nfunction CarouselComponent_a_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"a\", 10);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_5_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r16);\n      const ctx_r15 = i0.ɵɵnextContext();\n      return ctx_r15.previousSlide();\n    });\n    i0.ɵɵelement(1, \"span\", 11);\n    i0.ɵɵtemplate(2, CarouselComponent_a_5_span_2_Template, 2, 0, \"span\", 12);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r2.checkDisabledClass(\"prev\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#\" + ctx_r2.currentId);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.isBs4);\n  }\n}\n\nfunction CarouselComponent_a_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r18 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"a\", 14);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_a_6_Template_a_click_0_listener() {\n      i0.ɵɵrestoreView(_r18);\n      const ctx_r17 = i0.ɵɵnextContext();\n      return ctx_r17.nextSlide();\n    });\n    i0.ɵɵelement(1, \"span\", 15);\n    i0.ɵɵelementStart(2, \"span\", 13);\n    i0.ɵɵtext(3, \"Next\");\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"disabled\", ctx_r3.checkDisabledClass(\"next\"));\n    i0.ɵɵattribute(\"data-bs-target\", \"#\" + ctx_r3.currentId);\n  }\n}\n\nconst _c0 = function (a0) {\n  return {\n    \"display\": a0\n  };\n};\n\nconst _c1 = [\"*\"];\n\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n\nfunction chunkByNumber(array, size) {\n  const out = [];\n  const n = Math.ceil(array.length / size);\n  let i = 0;\n\n  while (i < n) {\n    const chunk = array.splice(0, i === n - 1 && size < array.length ? array.length : size);\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\nclass CarouselConfig {\n  constructor() {\n    /* Default interval of auto changing of slides */\n    this.interval = 5000;\n    /* Is loop of auto changing of slides can be paused */\n\n    this.noPause = false;\n    /* Is slides can wrap from the last to the first slide */\n\n    this.noWrap = false;\n    /* Show carousel-indicators */\n\n    this.showIndicators = true;\n    /* Slides can be paused on focus */\n\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n      of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n  }\n\n}\n\nCarouselConfig.ɵfac = function CarouselConfig_Factory(t) {\n  return new (t || CarouselConfig)();\n};\n\nCarouselConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CarouselConfig,\n  factory: CarouselConfig.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselConfig, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n  Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\n\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\n\nclass CarouselComponent {\n  constructor(config, ngZone) {\n    this.ngZone = ngZone;\n    /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n\n    this.noWrap = false;\n    /*  If `true` — will disable pausing on carousel mouse hover */\n\n    this.noPause = false;\n    /*  If `true` — carousel-indicators are visible  */\n\n    this.showIndicators = true;\n    /*  If `true` - autoplay will be stopped on focus */\n\n    this.pauseOnFocus = false;\n    /* If `true` - carousel indicators indicate slides chunks\n       works ONLY if singleSlideOffset = FALSE */\n\n    this.indicatorsByChunk = false;\n    /* If value more then 1 — carousel works in multilist mode */\n\n    this.itemsPerSlide = 1;\n    /* If `true` — carousel shifts by one element. By default carousel shifts by number\n       of visible elements (itemsPerSlide field) */\n\n    this.singleSlideOffset = false;\n    /** Turn on/off animation. Animation doesn't work for multilist carousel */\n\n    this.isAnimated = false;\n    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n\n    this.activeSlideChange = new EventEmitter(false);\n    /** Will be emitted when active slides has been changed in multilist mode */\n\n    this.slideRangeChange = new EventEmitter();\n    /* Index to start display slides from it */\n\n    this.startFromIndex = 0;\n    this._interval = 5000;\n    this._slides = new LinkedList();\n    this._currentVisibleSlidesIndex = 0;\n    this.isPlaying = false;\n    this.destroyed = false;\n    this.currentId = 0;\n\n    this.getActive = slide => slide.active;\n\n    this.makeSlidesConsistent = slides => {\n      slides.forEach((slide, index) => slide.item.order = index);\n    };\n\n    Object.assign(this, config);\n    this.currentId = _currentId++;\n  }\n  /** Index of currently displayed slide(started for 0) */\n\n\n  set activeSlide(index) {\n    if (this.multilist) {\n      return;\n    }\n\n    if (isNumber(index)) {\n      this.customActiveSlide = index;\n    }\n\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide() {\n    return this._currentActiveSlide || 0;\n  }\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n\n\n  get interval() {\n    return this._interval;\n  }\n\n  set interval(value) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides() {\n    return this._slides.toArray();\n  }\n\n  get isFirstSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n\n    return indexes.includes(0);\n  }\n\n  get isLastSlideVisible() {\n    const indexes = this.getVisibleIndexes();\n\n    if (!indexes || indexes instanceof Array && !indexes.length) {\n      return false;\n    }\n\n    return indexes.includes(this._slides.length - 1);\n  }\n\n  get isBs4() {\n    return !isBs3();\n  }\n\n  get _bsVer() {\n    return getBsVer();\n  }\n\n  ngAfterViewInit() {\n    setTimeout(() => {\n      if (this.singleSlideOffset) {\n        this.indicatorsByChunk = false;\n      }\n\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n        this.selectInitialSlides();\n      }\n\n      if (this.customActiveSlide && !this.multilist) {\n        this._select(this.customActiveSlide);\n      }\n    }, 0);\n  }\n\n  ngOnDestroy() {\n    this.destroyed = true;\n  }\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n\n\n  addSlide(slide) {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this.isAnimated) {\n      slide.isAnimated = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n\n      if (!this.customActiveSlide) {\n        this.activeSlide = 0;\n      }\n\n      this.play();\n    }\n\n    if (this.multilist && this._slides.length > this.itemsPerSlide) {\n      this.play();\n    }\n  }\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n\n\n  removeSlide(slide) {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex;\n\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex) ? remIndex : this.noWrap ? remIndex - 1 : 0;\n      }\n\n      this._slides.remove(remIndex); // prevents exception with changing some value after checking\n\n\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  nextSlideFromInterval(force = false) {\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n\n\n  nextSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.NEXT, force);\n  }\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n\n\n  previousSlide(force = false) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    this.move(Direction.PREV, force);\n  }\n\n  getFirstVisibleIndex() {\n    return this.slides.findIndex(this.getActive);\n  }\n\n  getLastVisibleIndex() {\n    return findLastIndex(this.slides, this.getActive);\n  }\n\n  move(direction, force = false) {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (direction === Direction.NEXT && this.isLast(lastVisibleIndex) || direction === Direction.PREV && firstVisibleIndex === 0) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n  /**\n   * Swith slides by enter, space and arrows keys\n   * @internal\n   */\n\n\n  keydownPress(event) {\n    if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n      this.nextSlide();\n      event.preventDefault();\n      return;\n    }\n\n    if (event.keyCode === 37 || event.key === 'LeftArrow') {\n      this.previousSlide();\n      return;\n    }\n\n    if (event.keyCode === 39 || event.key === 'RightArrow') {\n      this.nextSlide();\n      return;\n    }\n  }\n  /**\n   * Play on mouse leave\n   * @internal\n   */\n\n\n  onMouseLeave() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * Play on mouse up\n   * @internal\n   */\n\n\n  onMouseUp() {\n    if (!this.pauseOnFocus) {\n      this.play();\n    }\n  }\n  /**\n   * When slides on focus autoplay is stopped(optional)\n   * @internal\n   */\n\n\n  pauseFocusIn() {\n    if (this.pauseOnFocus) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * When slides out of focus autoplay is started\n   * @internal\n   */\n\n\n  pauseFocusOut() {\n    this.play();\n  }\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n\n\n  selectSlide(index) {\n    if (this.isPlaying) {\n      this.restartTimer();\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n    } else {\n      this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n    }\n  }\n  /**\n   * Starts a auto changing of slides\n   */\n\n\n  play() {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n  /**\n   * Stops a auto changing of slides\n   */\n\n\n  pause() {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n\n\n  getCurrentSlideIndex() {\n    return this._slides.findIndex(this.getActive);\n  }\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n\n\n  isLast(index) {\n    return index + 1 >= this._slides.length;\n  }\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n\n\n  isFirst(index) {\n    return index === 0;\n  }\n\n  indicatorsSlides() {\n    return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n  }\n\n  selectInitialSlides() {\n    const startIndex = this.startFromIndex <= this._slides.length ? this.startFromIndex : 0;\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes = [...this._slidesWithIndexes, ...slidesToAppend].slice(slidesToAppend.length).slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n      }\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n\n\n  findNextSlideIndex(direction, force) {\n    let nextSlideIndex = 0;\n\n    if (!force && this.isLast(this.activeSlide) && direction !== Direction.PREV && this.noWrap) {\n      return;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n\n        if (!this.isLast(this._currentActiveSlide)) {\n          nextSlideIndex = this._currentActiveSlide + 1;\n          break;\n        }\n\n        nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        if (typeof this._currentActiveSlide === 'undefined') {\n          nextSlideIndex = 0;\n          break;\n        }\n\n        if (this._currentActiveSlide > 0) {\n          nextSlideIndex = this._currentActiveSlide - 1;\n          break;\n        }\n\n        if (!force && this.noWrap) {\n          nextSlideIndex = this._currentActiveSlide;\n          break;\n        }\n\n        nextSlideIndex = this._slides.length - 1;\n        break;\n\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  mapSlidesAndIndexes() {\n    return this.slides.slice().map((slide, index) => {\n      return {\n        index,\n        item: slide\n      };\n    });\n  }\n\n  selectSlideRange(index) {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index) ? index : index - this.itemsPerSlide + 1;\n      const endIndex = this.isIndexOnTheEdges(index) ? index + this.itemsPerSlide : index + 1;\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent(this._slidesWithIndexes);\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  selectRangeByNestedIndex(index) {\n    if (!this._chunkedSlides) {\n      return;\n    }\n\n    const selectedRange = this._chunkedSlides.map((slidesList, i) => {\n      return {\n        index: i,\n        list: slidesList\n      };\n    }).find(slidesList => {\n      return slidesList.list.find(slide => slide.index === index) !== undefined;\n    });\n\n    if (!selectedRange) {\n      return;\n    }\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach(slide => {\n      slide.item.active = true;\n    });\n  }\n\n  isIndexOnTheEdges(index) {\n    return index + 1 - this.itemsPerSlide <= 0 || index + this.itemsPerSlide <= this._slides.length;\n  }\n\n  isIndexInRange(index) {\n    if (this.singleSlideOffset && this._slidesWithIndexes) {\n      const visibleIndexes = this._slidesWithIndexes.map(slide => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return index <= this.getLastVisibleIndex() && index >= this.getFirstVisibleIndex();\n  }\n\n  hideSlides() {\n    this.slides.forEach(slide => slide.active = false);\n  }\n\n  isVisibleSlideListLast() {\n    if (!this._chunkedSlides) {\n      return false;\n    }\n\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n\n  isVisibleSlideListFirst() {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n\n  moveSliderByOneItem(direction) {\n    let firstVisibleIndex;\n    let lastVisibleIndex;\n    let indexToHide;\n    let indexToShow;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n      indexToHide = direction === Direction.NEXT ? firstVisibleIndex : lastVisibleIndex;\n      indexToShow = direction !== Direction.NEXT ? firstVisibleIndex - 1 : !this.isLast(lastVisibleIndex) ? lastVisibleIndex + 1 : 0;\n\n      const slideToHide = this._slides.get(indexToHide);\n\n      if (slideToHide) {\n        slideToHide.active = false;\n      }\n\n      const slideToShow = this._slides.get(indexToShow);\n\n      if (slideToShow) {\n        slideToShow.active = true;\n      }\n\n      const slidesToReorder = this.mapSlidesAndIndexes().filter(slide => slide.item.active);\n      this.makeSlidesConsistent(slidesToReorder);\n\n      if (this.singleSlideOffset) {\n        this._slidesWithIndexes = slidesToReorder;\n      }\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n      return;\n    }\n\n    if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n      return;\n    }\n\n    let index;\n    firstVisibleIndex = this._slidesWithIndexes[0].index;\n    lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n    if (direction === Direction.NEXT) {\n      this._slidesWithIndexes.shift();\n\n      index = this.isLast(lastVisibleIndex) ? 0 : lastVisibleIndex + 1;\n\n      const item = this._slides.get(index);\n\n      if (item) {\n        this._slidesWithIndexes.push({\n          index,\n          item\n        });\n      }\n    } else {\n      this._slidesWithIndexes.pop();\n\n      index = this.isFirst(firstVisibleIndex) ? this._slides.length - 1 : firstVisibleIndex - 1;\n\n      const item = this._slides.get(index);\n\n      if (item) {\n        this._slidesWithIndexes = [{\n          index,\n          item\n        }, ...this._slidesWithIndexes];\n      }\n    }\n\n    this.hideSlides();\n\n    this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n    this.makeSlidesConsistent(this._slidesWithIndexes);\n    this.slideRangeChange.emit(this._slidesWithIndexes.map(slide => slide.index));\n  }\n\n  moveMultilist(direction) {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT ? this._currentVisibleSlidesIndex + 1 : this._currentVisibleSlidesIndex - 1;\n      } else if (direction === Direction.NEXT) {\n        this._currentVisibleSlidesIndex = this.isVisibleSlideListLast() ? 0 : this._currentVisibleSlidesIndex + 1;\n      } else {\n        if (this.isVisibleSlideListFirst()) {\n          this._currentVisibleSlidesIndex = this._chunkedSlides ? this._chunkedSlides.length - 1 : 0;\n        } else {\n          this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      if (this._chunkedSlides) {\n        this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(slide => slide.item.active = true);\n      }\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n\n  getVisibleIndexes() {\n    if (!this.singleSlideOffset && this._chunkedSlides) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex].map(slide => slide.index);\n    }\n\n    if (this._slidesWithIndexes) {\n      return this._slidesWithIndexes.map(slide => slide.index);\n    }\n  }\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n\n\n  _select(index) {\n    if (isNaN(index)) {\n      this.pause();\n      return;\n    }\n\n    if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n\n      if (typeof currentSlide !== 'undefined') {\n        currentSlide.active = false;\n      }\n    }\n\n    const nextSlide = this._slides.get(index);\n\n    if (typeof nextSlide !== 'undefined') {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n  /**\n   * Starts loop of auto changing of slides\n   */\n\n\n  restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return window.setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (this.isPlaying && !isNaN(this.interval) && nInterval > 0 && this.slides.length) {\n              this.nextSlideFromInterval();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  get multilist() {\n    return this.itemsPerSlide > 1;\n  }\n  /**\n   * Stops loop of auto changing of slides\n   */\n\n\n  resetTimer() {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n\n  checkDisabledClass(buttonType) {\n    if (buttonType === 'prev') {\n      return this.activeSlide === 0 && this.noWrap && !this.multilist || this.isFirstSlideVisible && this.noWrap && this.multilist;\n    }\n\n    return this.isLast(this.activeSlide) && this.noWrap && !this.multilist || this.isLastSlideVisible && this.noWrap && this.multilist;\n  }\n\n}\n\nCarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n  return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(CarouselConfig), i0.ɵɵdirectiveInject(i0.NgZone));\n};\n\nCarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: CarouselComponent,\n  selectors: [[\"carousel\"]],\n  inputs: {\n    noWrap: \"noWrap\",\n    noPause: \"noPause\",\n    showIndicators: \"showIndicators\",\n    pauseOnFocus: \"pauseOnFocus\",\n    indicatorsByChunk: \"indicatorsByChunk\",\n    itemsPerSlide: \"itemsPerSlide\",\n    singleSlideOffset: \"singleSlideOffset\",\n    isAnimated: \"isAnimated\",\n    activeSlide: \"activeSlide\",\n    startFromIndex: \"startFromIndex\",\n    interval: \"interval\"\n  },\n  outputs: {\n    activeSlideChange: \"activeSlideChange\",\n    slideRangeChange: \"slideRangeChange\"\n  },\n  ngContentSelectors: _c1,\n  decls: 7,\n  vars: 8,\n  consts: [[\"tabindex\", \"0\", 1, \"carousel\", \"slide\", 3, \"id\", \"mouseenter\", \"mouseleave\", \"mouseup\", \"keydown\", \"focusin\", \"focusout\"], [4, \"ngIf\"], [1, \"carousel-inner\", 3, \"ngStyle\"], [\"class\", \"left carousel-control carousel-control-prev\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [\"class\", \"right carousel-control carousel-control-next\", \"tabindex\", \"0\", \"role\", \"button\", 3, \"disabled\", \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"click\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", \"aria-current\", \"true\", 3, \"click\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"left\", \"carousel-control\", \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-prev\", \"carousel-control-prev-icon\"], [\"class\", \"sr-only visually-hidden\", 4, \"ngIf\"], [1, \"sr-only\", \"visually-hidden\"], [\"tabindex\", \"0\", \"role\", \"button\", 1, \"right\", \"carousel-control\", \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"icon-next\", \"carousel-control-next-icon\"]],\n  template: function CarouselComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵlistener(\"mouseenter\", function CarouselComponent_Template_div_mouseenter_0_listener() {\n        return ctx.pause();\n      })(\"mouseleave\", function CarouselComponent_Template_div_mouseleave_0_listener() {\n        return ctx.onMouseLeave();\n      })(\"mouseup\", function CarouselComponent_Template_div_mouseup_0_listener() {\n        return ctx.onMouseUp();\n      })(\"keydown\", function CarouselComponent_Template_div_keydown_0_listener($event) {\n        return ctx.keydownPress($event);\n      })(\"focusin\", function CarouselComponent_Template_div_focusin_0_listener() {\n        return ctx.pauseFocusIn();\n      })(\"focusout\", function CarouselComponent_Template_div_focusout_0_listener() {\n        return ctx.pauseFocusOut();\n      });\n      i0.ɵɵtemplate(1, CarouselComponent_ng_container_1_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_Template, 3, 1, \"ng-container\", 1);\n      i0.ɵɵelementStart(3, \"div\", 2);\n      i0.ɵɵprojection(4);\n      i0.ɵɵelementEnd();\n      i0.ɵɵtemplate(5, CarouselComponent_a_5_Template, 3, 4, \"a\", 3);\n      i0.ɵɵtemplate(6, CarouselComponent_a_6_Template, 4, 3, \"a\", 4);\n      i0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"id\", ctx.currentId);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", !ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx._bsVer.isBs5 && ctx.showIndicators && ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngStyle\", i0.ɵɵpureFunction1(6, _c0, ctx.multilist ? \"flex\" : \"block\"));\n      i0.ɵɵadvance(2);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngIf\", ctx.slides.length > 1);\n    }\n  },\n  directives: [i2.NgIf, i2.NgForOf, i2.NgStyle],\n  encapsulation: 2\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselComponent, [{\n    type: Component,\n    args: [{\n      selector: 'carousel',\n      template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"previousSlide()\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: CarouselConfig\n    }, {\n      type: i0.NgZone\n    }];\n  }, {\n    noWrap: [{\n      type: Input\n    }],\n    noPause: [{\n      type: Input\n    }],\n    showIndicators: [{\n      type: Input\n    }],\n    pauseOnFocus: [{\n      type: Input\n    }],\n    indicatorsByChunk: [{\n      type: Input\n    }],\n    itemsPerSlide: [{\n      type: Input\n    }],\n    singleSlideOffset: [{\n      type: Input\n    }],\n    isAnimated: [{\n      type: Input\n    }],\n    activeSlideChange: [{\n      type: Output\n    }],\n    slideRangeChange: [{\n      type: Output\n    }],\n    activeSlide: [{\n      type: Input\n    }],\n    startFromIndex: [{\n      type: Input\n    }],\n    interval: [{\n      type: Input\n    }]\n  });\n})();\n\nclass SlideComponent {\n  constructor(carousel) {\n    /** Is current slide active */\n    this.active = false;\n    this.itemWidth = '100%';\n    this.order = 0;\n    this.isAnimated = false;\n    /** Wraps element by appropriate CSS classes */\n\n    this.addClass = true;\n    this.multilist = false;\n    this.carousel = carousel;\n  }\n  /** Fires changes in container collection after adding a new slide instance */\n\n\n  ngOnInit() {\n    var _a;\n\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n    this.multilist = ((_a = this.carousel) === null || _a === void 0 ? void 0 : _a.itemsPerSlide) > 1;\n  }\n  /** Fires changes in container collection after removing of this slide instance */\n\n\n  ngOnDestroy() {\n    this.carousel.removeSlide(this);\n  }\n\n}\n\nSlideComponent.ɵfac = function SlideComponent_Factory(t) {\n  return new (t || SlideComponent)(i0.ɵɵdirectiveInject(CarouselComponent));\n};\n\nSlideComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: SlideComponent,\n  selectors: [[\"slide\"]],\n  hostVars: 15,\n  hostBindings: function SlideComponent_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵattribute(\"aria-hidden\", !ctx.active);\n      i0.ɵɵstyleProp(\"width\", ctx.itemWidth)(\"order\", ctx.order);\n      i0.ɵɵclassProp(\"multilist-margin\", ctx.multilist)(\"active\", ctx.active)(\"carousel-animation\", ctx.isAnimated)(\"item\", ctx.addClass)(\"carousel-item\", ctx.addClass);\n    }\n  },\n  inputs: {\n    active: \"active\"\n  },\n  ngContentSelectors: _c1,\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"item\"]],\n  template: function SlideComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵprojectionDef();\n      i0.ɵɵelementStart(0, \"div\", 0);\n      i0.ɵɵprojection(1);\n      i0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵclassProp(\"active\", ctx.active);\n    }\n  },\n  styles: [\".carousel-animation[_nghost-%COMP%]{transition:opacity .6s ease,visibility .6s ease;float:left}.carousel-animation.active[_nghost-%COMP%]{opacity:1;visibility:visible}.carousel-animation[_nghost-%COMP%]:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}.multilist-margin[_nghost-%COMP%]{margin-right:auto}.carousel-item[_nghost-%COMP%]{perspective:1000px}\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SlideComponent, [{\n    type: Component,\n    args: [{\n      selector: 'slide',\n      template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n      // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n      host: {\n        '[attr.aria-hidden]': '!active',\n        '[class.multilist-margin]': 'multilist'\n      },\n      styles: [`\n    :host.carousel-animation {\n       transition: opacity 0.6s ease, visibility 0.6s ease;\n       float: left;\n    }\n    :host.carousel-animation.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    :host.carousel-animation:not(.active) {\n      display: block;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n    }\n    :host.multilist-margin {\n      margin-right: auto;\n    }\n    :host.carousel-item {\n      perspective: 1000px;\n    }\n  `]\n    }]\n  }], function () {\n    return [{\n      type: CarouselComponent\n    }];\n  }, {\n    active: [{\n      type: HostBinding,\n      args: ['class.active']\n    }, {\n      type: Input\n    }],\n    itemWidth: [{\n      type: HostBinding,\n      args: ['style.width']\n    }],\n    order: [{\n      type: HostBinding,\n      args: ['style.order']\n    }],\n    isAnimated: [{\n      type: HostBinding,\n      args: ['class.carousel-animation']\n    }],\n    addClass: [{\n      type: HostBinding,\n      args: ['class.item']\n    }, {\n      type: HostBinding,\n      args: ['class.carousel-item']\n    }]\n  });\n})();\n\nclass CarouselModule {\n  static forRoot() {\n    return {\n      ngModule: CarouselModule,\n      providers: []\n    };\n  }\n\n}\n\nCarouselModule.ɵfac = function CarouselModule_Factory(t) {\n  return new (t || CarouselModule)();\n};\n\nCarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: CarouselModule\n});\nCarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CarouselModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      declarations: [SlideComponent, CarouselComponent],\n      exports: [SlideComponent, CarouselComponent]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };","map":{"version":3,"names":["i0","Injectable","EventEmitter","Component","Input","Output","HostBinding","NgModule","LinkedList","isBs3","getBsVer","i2","CommonModule","findLastIndex","array","predicate","l","length","chunkByNumber","size","out","n","Math","ceil","i","chunk","splice","push","isNumber","value","Object","prototype","toString","call","CarouselConfig","constructor","interval","noPause","noWrap","showIndicators","pauseOnFocus","indicatorsByChunk","itemsPerSlide","singleSlideOffset","ɵfac","ɵprov","type","args","providedIn","Direction","_currentId","CarouselComponent","config","ngZone","isAnimated","activeSlideChange","slideRangeChange","startFromIndex","_interval","_slides","_currentVisibleSlidesIndex","isPlaying","destroyed","currentId","getActive","slide","active","makeSlidesConsistent","slides","forEach","index","item","order","assign","activeSlide","multilist","customActiveSlide","_currentActiveSlide","_select","restartTimer","toArray","isFirstSlideVisible","indexes","getVisibleIndexes","Array","includes","isLastSlideVisible","isBs4","_bsVer","ngAfterViewInit","setTimeout","_chunkedSlides","mapSlidesAndIndexes","selectInitialSlides","ngOnDestroy","addSlide","add","undefined","play","removeSlide","remIndex","indexOf","nextSlideIndex","isLast","remove","currentSlideIndex","getCurrentSlideIndex","emit","nextSlideFromInterval","force","move","NEXT","nextSlide","previousSlide","PREV","getFirstVisibleIndex","findIndex","getLastVisibleIndex","direction","firstVisibleIndex","lastVisibleIndex","findNextSlideIndex","moveMultilist","keydownPress","event","keyCode","key","preventDefault","onMouseLeave","onMouseUp","pauseFocusIn","resetTimer","pauseFocusOut","selectSlide","selectSlideRange","pause","isFirst","indicatorsSlides","filter","startIndex","hideSlides","_slidesWithIndexes","slidesToAppend","slice","selectRangeByNestedIndex","Error","map","isIndexInRange","isIndexOnTheEdges","endIndex","selectedRange","slidesList","list","find","visibleIndexes","isVisibleSlideListLast","isVisibleSlideListFirst","moveSliderByOneItem","indexToHide","indexToShow","slideToHide","get","slideToShow","slidesToReorder","shift","pop","isNaN","currentSlide","currentInterval","runOutsideAngular","window","setInterval","nInterval","run","clearInterval","checkDisabledClass","buttonType","NgZone","ɵcmp","NgIf","NgForOf","NgStyle","selector","template","SlideComponent","carousel","itemWidth","addClass","ngOnInit","_a","host","styles","CarouselModule","forRoot","ngModule","providers","ɵmod","ɵinj","imports","declarations","exports"],"sources":["D:/Tutorial/HerosApp/node_modules/ngx-bootstrap/carousel/fesm2015/ngx-bootstrap-carousel.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, Input, Output, HostBinding, NgModule } from '@angular/core';\nimport { LinkedList, isBs3, getBsVer } from 'ngx-bootstrap/utils';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nfunction findLastIndex(array, predicate) {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) {\n            return l;\n        }\n    }\n    return -1;\n}\nfunction chunkByNumber(array, size) {\n    const out = [];\n    const n = Math.ceil((array.length) / size);\n    let i = 0;\n    while (i < n) {\n        const chunk = array.splice(0, (i === n - 1) && size < array.length ? array.length : size);\n        out.push(chunk);\n        i++;\n    }\n    return out;\n}\nfunction isNumber(value) {\n    return typeof value === 'number' || Object.prototype.toString.call(value) === '[object Number]';\n}\n\nclass CarouselConfig {\n    constructor() {\n        /* Default interval of auto changing of slides */\n        this.interval = 5000;\n        /* Is loop of auto changing of slides can be paused */\n        this.noPause = false;\n        /* Is slides can wrap from the last to the first slide */\n        this.noWrap = false;\n        /* Show carousel-indicators */\n        this.showIndicators = true;\n        /* Slides can be paused on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n          of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n    }\n}\nCarouselConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nCarouselConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselConfig, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselConfig, decorators: [{\n            type: Injectable,\n            args: [{\n                    providedIn: 'root'\n                }]\n        }] });\n\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n    Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n})(Direction || (Direction = {}));\nlet _currentId = 1;\n/**\n * Base element to create carousel\n */\nclass CarouselComponent {\n    constructor(config, ngZone) {\n        this.ngZone = ngZone;\n        /* If `true` — carousel will not cycle continuously and will have hard stops (prevent looping) */\n        this.noWrap = false;\n        /*  If `true` — will disable pausing on carousel mouse hover */\n        this.noPause = false;\n        /*  If `true` — carousel-indicators are visible  */\n        this.showIndicators = true;\n        /*  If `true` - autoplay will be stopped on focus */\n        this.pauseOnFocus = false;\n        /* If `true` - carousel indicators indicate slides chunks\n           works ONLY if singleSlideOffset = FALSE */\n        this.indicatorsByChunk = false;\n        /* If value more then 1 — carousel works in multilist mode */\n        this.itemsPerSlide = 1;\n        /* If `true` — carousel shifts by one element. By default carousel shifts by number\n           of visible elements (itemsPerSlide field) */\n        this.singleSlideOffset = false;\n        /** Turn on/off animation. Animation doesn't work for multilist carousel */\n        this.isAnimated = false;\n        /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n        this.activeSlideChange = new EventEmitter(false);\n        /** Will be emitted when active slides has been changed in multilist mode */\n        this.slideRangeChange = new EventEmitter();\n        /* Index to start display slides from it */\n        this.startFromIndex = 0;\n        this._interval = 5000;\n        this._slides = new LinkedList();\n        this._currentVisibleSlidesIndex = 0;\n        this.isPlaying = false;\n        this.destroyed = false;\n        this.currentId = 0;\n        this.getActive = (slide) => slide.active;\n        this.makeSlidesConsistent = (slides) => {\n            slides.forEach((slide, index) => slide.item.order = index);\n        };\n        Object.assign(this, config);\n        this.currentId = _currentId++;\n    }\n    /** Index of currently displayed slide(started for 0) */\n    set activeSlide(index) {\n        if (this.multilist) {\n            return;\n        }\n        if (isNumber(index)) {\n            this.customActiveSlide = index;\n        }\n        if (this._slides.length && index !== this._currentActiveSlide) {\n            this._select(index);\n        }\n    }\n    get activeSlide() {\n        return this._currentActiveSlide || 0;\n    }\n    /**\n     * Delay of item cycling in milliseconds. If false, carousel won't cycle\n     * automatically.\n     */\n    get interval() {\n        return this._interval;\n    }\n    set interval(value) {\n        this._interval = value;\n        this.restartTimer();\n    }\n    get slides() {\n        return this._slides.toArray();\n    }\n    get isFirstSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(0);\n    }\n    get isLastSlideVisible() {\n        const indexes = this.getVisibleIndexes();\n        if (!indexes || (indexes instanceof Array && !indexes.length)) {\n            return false;\n        }\n        return indexes.includes(this._slides.length - 1);\n    }\n    get isBs4() {\n        return !isBs3();\n    }\n    get _bsVer() {\n        return getBsVer();\n    }\n    ngAfterViewInit() {\n        setTimeout(() => {\n            if (this.singleSlideOffset) {\n                this.indicatorsByChunk = false;\n            }\n            if (this.multilist) {\n                this._chunkedSlides = chunkByNumber(this.mapSlidesAndIndexes(), this.itemsPerSlide);\n                this.selectInitialSlides();\n            }\n            if (this.customActiveSlide && !this.multilist) {\n                this._select(this.customActiveSlide);\n            }\n        }, 0);\n    }\n    ngOnDestroy() {\n        this.destroyed = true;\n    }\n    /**\n     * Adds new slide. If this slide is first in collection - set it as active\n     * and starts auto changing\n     * @param slide\n     */\n    addSlide(slide) {\n        this._slides.add(slide);\n        if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n            slide.active = true;\n        }\n        if (!this.multilist && this.isAnimated) {\n            slide.isAnimated = true;\n        }\n        if (!this.multilist && this._slides.length === 1) {\n            this._currentActiveSlide = undefined;\n            if (!this.customActiveSlide) {\n                this.activeSlide = 0;\n            }\n            this.play();\n        }\n        if (this.multilist && this._slides.length > this.itemsPerSlide) {\n            this.play();\n        }\n    }\n    /**\n     * Removes specified slide. If this slide is active - will roll to another\n     * slide\n     * @param slide\n     */\n    removeSlide(slide) {\n        const remIndex = this._slides.indexOf(slide);\n        if (this._currentActiveSlide === remIndex) {\n            // removing of active slide\n            let nextSlideIndex;\n            if (this._slides.length > 1) {\n                // if this slide last - will roll to first slide, if noWrap flag is\n                // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n                // middle of collection, index of next slide is same to removed\n                nextSlideIndex = !this.isLast(remIndex)\n                    ? remIndex\n                    : this.noWrap ? remIndex - 1 : 0;\n            }\n            this._slides.remove(remIndex);\n            // prevents exception with changing some value after checking\n            setTimeout(() => {\n                this._select(nextSlideIndex);\n            }, 0);\n        }\n        else {\n            this._slides.remove(remIndex);\n            const currentSlideIndex = this.getCurrentSlideIndex();\n            setTimeout(() => {\n                // after removing, need to actualize index of current active slide\n                this._currentActiveSlide = currentSlideIndex;\n                this.activeSlideChange.emit(this._currentActiveSlide);\n            }, 0);\n        }\n    }\n    nextSlideFromInterval(force = false) {\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to next slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    nextSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.NEXT, force);\n    }\n    /**\n     * Rolling to previous slide\n     * @param force: {boolean} if true - will ignore noWrap flag\n     */\n    previousSlide(force = false) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        this.move(Direction.PREV, force);\n    }\n    getFirstVisibleIndex() {\n        return this.slides.findIndex(this.getActive);\n    }\n    getLastVisibleIndex() {\n        return findLastIndex(this.slides, this.getActive);\n    }\n    move(direction, force = false) {\n        const firstVisibleIndex = this.getFirstVisibleIndex();\n        const lastVisibleIndex = this.getLastVisibleIndex();\n        if (this.noWrap) {\n            if (direction === Direction.NEXT &&\n                this.isLast(lastVisibleIndex) ||\n                direction === Direction.PREV &&\n                    firstVisibleIndex === 0) {\n                return;\n            }\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.findNextSlideIndex(direction, force) || 0;\n        }\n        else {\n            this.moveMultilist(direction);\n        }\n    }\n    /**\n     * Swith slides by enter, space and arrows keys\n     * @internal\n     */\n    keydownPress(event) {\n        if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n            this.nextSlide();\n            event.preventDefault();\n            return;\n        }\n        if (event.keyCode === 37 || event.key === 'LeftArrow') {\n            this.previousSlide();\n            return;\n        }\n        if (event.keyCode === 39 || event.key === 'RightArrow') {\n            this.nextSlide();\n            return;\n        }\n    }\n    /**\n     * Play on mouse leave\n     * @internal\n     */\n    onMouseLeave() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * Play on mouse up\n     * @internal\n     */\n    onMouseUp() {\n        if (!this.pauseOnFocus) {\n            this.play();\n        }\n    }\n    /**\n     * When slides on focus autoplay is stopped(optional)\n     * @internal\n     */\n    pauseFocusIn() {\n        if (this.pauseOnFocus) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * When slides out of focus autoplay is started\n     * @internal\n     */\n    pauseFocusOut() {\n        this.play();\n    }\n    /**\n     * Rolling to specified slide\n     * @param index: {number} index of slide, which must be shown\n     */\n    selectSlide(index) {\n        if (this.isPlaying) {\n            this.restartTimer();\n        }\n        if (!this.multilist) {\n            this.activeSlide = this.indicatorsByChunk ? index * this.itemsPerSlide : index;\n        }\n        else {\n            this.selectSlideRange(this.indicatorsByChunk ? index * this.itemsPerSlide : index);\n        }\n    }\n    /**\n     * Starts a auto changing of slides\n     */\n    play() {\n        if (!this.isPlaying) {\n            this.isPlaying = true;\n            this.restartTimer();\n        }\n    }\n    /**\n     * Stops a auto changing of slides\n     */\n    pause() {\n        if (!this.noPause) {\n            this.isPlaying = false;\n            this.resetTimer();\n        }\n    }\n    /**\n     * Finds and returns index of currently displayed slide\n     */\n    getCurrentSlideIndex() {\n        return this._slides.findIndex(this.getActive);\n    }\n    /**\n     * Defines, whether the specified index is last in collection\n     * @param index\n     */\n    isLast(index) {\n        return index + 1 >= this._slides.length;\n    }\n    /**\n     * Defines, whether the specified index is first in collection\n     * @param index\n     */\n    isFirst(index) {\n        return index === 0;\n    }\n    indicatorsSlides() {\n        return this.slides.filter((slide, index) => !this.indicatorsByChunk || index % this.itemsPerSlide === 0);\n    }\n    selectInitialSlides() {\n        const startIndex = this.startFromIndex <= this._slides.length\n            ? this.startFromIndex\n            : 0;\n        this.hideSlides();\n        if (this.singleSlideOffset) {\n            this._slidesWithIndexes = this.mapSlidesAndIndexes();\n            if (this._slides.length - startIndex < this.itemsPerSlide) {\n                const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n                this._slidesWithIndexes = [\n                    ...this._slidesWithIndexes,\n                    ...slidesToAppend\n                ]\n                    .slice(slidesToAppend.length)\n                    .slice(0, this.itemsPerSlide);\n            }\n            else {\n                this._slidesWithIndexes = this._slidesWithIndexes.slice(startIndex, startIndex + this.itemsPerSlide);\n            }\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n        }\n        else {\n            this.selectRangeByNestedIndex(startIndex);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    /**\n     * Defines next slide index, depending of direction\n     * @param direction: Direction(UNKNOWN|PREV|NEXT)\n     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n     *   return undefined if next slide require wrapping\n     */\n    findNextSlideIndex(direction, force) {\n        let nextSlideIndex = 0;\n        if (!force &&\n            (this.isLast(this.activeSlide) &&\n                direction !== Direction.PREV &&\n                this.noWrap)) {\n            return;\n        }\n        switch (direction) {\n            case Direction.NEXT:\n                // if this is last slide, not force, looping is disabled\n                // and need to going forward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (!this.isLast(this._currentActiveSlide)) {\n                    nextSlideIndex = this._currentActiveSlide + 1;\n                    break;\n                }\n                nextSlideIndex = !force && this.noWrap ? this._currentActiveSlide : 0;\n                break;\n            case Direction.PREV:\n                // if this is first slide, not force, looping is disabled\n                // and need to going backward - select current slide, as a next\n                if (typeof this._currentActiveSlide === 'undefined') {\n                    nextSlideIndex = 0;\n                    break;\n                }\n                if (this._currentActiveSlide > 0) {\n                    nextSlideIndex = this._currentActiveSlide - 1;\n                    break;\n                }\n                if (!force && this.noWrap) {\n                    nextSlideIndex = this._currentActiveSlide;\n                    break;\n                }\n                nextSlideIndex = this._slides.length - 1;\n                break;\n            default:\n                throw new Error('Unknown direction');\n        }\n        return nextSlideIndex;\n    }\n    mapSlidesAndIndexes() {\n        return this.slides\n            .slice()\n            .map((slide, index) => {\n            return {\n                index,\n                item: slide\n            };\n        });\n    }\n    selectSlideRange(index) {\n        if (this.isIndexInRange(index)) {\n            return;\n        }\n        this.hideSlides();\n        if (!this.singleSlideOffset) {\n            this.selectRangeByNestedIndex(index);\n        }\n        else {\n            const startIndex = this.isIndexOnTheEdges(index)\n                ? index\n                : index - this.itemsPerSlide + 1;\n            const endIndex = this.isIndexOnTheEdges(index)\n                ? index + this.itemsPerSlide\n                : index + 1;\n            this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n            this.makeSlidesConsistent(this._slidesWithIndexes);\n            this._slidesWithIndexes.forEach((slide) => slide.item.active = true);\n        }\n        this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n    selectRangeByNestedIndex(index) {\n        if (!this._chunkedSlides) {\n            return;\n        }\n        const selectedRange = this._chunkedSlides\n            .map((slidesList, i) => {\n            return {\n                index: i,\n                list: slidesList\n            };\n        })\n            .find((slidesList) => {\n            return slidesList.list.find(slide => slide.index === index) !== undefined;\n        });\n        if (!selectedRange) {\n            return;\n        }\n        this._currentVisibleSlidesIndex = selectedRange.index;\n        this._chunkedSlides[selectedRange.index].forEach((slide) => {\n            slide.item.active = true;\n        });\n    }\n    isIndexOnTheEdges(index) {\n        return (index + 1 - this.itemsPerSlide <= 0 ||\n            index + this.itemsPerSlide <= this._slides.length);\n    }\n    isIndexInRange(index) {\n        if (this.singleSlideOffset && this._slidesWithIndexes) {\n            const visibleIndexes = this._slidesWithIndexes.map((slide) => slide.index);\n            return visibleIndexes.indexOf(index) >= 0;\n        }\n        return (index <= this.getLastVisibleIndex() &&\n            index >= this.getFirstVisibleIndex());\n    }\n    hideSlides() {\n        this.slides.forEach((slide) => slide.active = false);\n    }\n    isVisibleSlideListLast() {\n        if (!this._chunkedSlides) {\n            return false;\n        }\n        return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n    }\n    isVisibleSlideListFirst() {\n        return this._currentVisibleSlidesIndex === 0;\n    }\n    moveSliderByOneItem(direction) {\n        let firstVisibleIndex;\n        let lastVisibleIndex;\n        let indexToHide;\n        let indexToShow;\n        if (this.noWrap) {\n            firstVisibleIndex = this.getFirstVisibleIndex();\n            lastVisibleIndex = this.getLastVisibleIndex();\n            indexToHide = direction === Direction.NEXT\n                ? firstVisibleIndex\n                : lastVisibleIndex;\n            indexToShow = direction !== Direction.NEXT\n                ? firstVisibleIndex - 1\n                : !this.isLast(lastVisibleIndex)\n                    ? lastVisibleIndex + 1 : 0;\n            const slideToHide = this._slides.get(indexToHide);\n            if (slideToHide) {\n                slideToHide.active = false;\n            }\n            const slideToShow = this._slides.get(indexToShow);\n            if (slideToShow) {\n                slideToShow.active = true;\n            }\n            const slidesToReorder = this.mapSlidesAndIndexes().filter((slide) => slide.item.active);\n            this.makeSlidesConsistent(slidesToReorder);\n            if (this.singleSlideOffset) {\n                this._slidesWithIndexes = slidesToReorder;\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n            return;\n        }\n        if (!this._slidesWithIndexes || !this._slidesWithIndexes[0]) {\n            return;\n        }\n        let index;\n        firstVisibleIndex = this._slidesWithIndexes[0].index;\n        lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n        if (direction === Direction.NEXT) {\n            this._slidesWithIndexes.shift();\n            index = this.isLast(lastVisibleIndex)\n                ? 0\n                : lastVisibleIndex + 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes.push({ index, item });\n            }\n        }\n        else {\n            this._slidesWithIndexes.pop();\n            index = this.isFirst(firstVisibleIndex)\n                ? this._slides.length - 1\n                : firstVisibleIndex - 1;\n            const item = this._slides.get(index);\n            if (item) {\n                this._slidesWithIndexes = [{ index, item }, ...this._slidesWithIndexes];\n            }\n        }\n        this.hideSlides();\n        this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n        this.makeSlidesConsistent(this._slidesWithIndexes);\n        this.slideRangeChange.emit(this._slidesWithIndexes.map((slide) => slide.index));\n    }\n    moveMultilist(direction) {\n        if (this.singleSlideOffset) {\n            this.moveSliderByOneItem(direction);\n        }\n        else {\n            this.hideSlides();\n            if (this.noWrap) {\n                this._currentVisibleSlidesIndex = direction === Direction.NEXT\n                    ? this._currentVisibleSlidesIndex + 1\n                    : this._currentVisibleSlidesIndex - 1;\n            }\n            else if (direction === Direction.NEXT) {\n                this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n                    ? 0\n                    : this._currentVisibleSlidesIndex + 1;\n            }\n            else {\n                if (this.isVisibleSlideListFirst()) {\n                    this._currentVisibleSlidesIndex = this._chunkedSlides\n                        ? this._chunkedSlides.length - 1\n                        : 0;\n                }\n                else {\n                    this._currentVisibleSlidesIndex = this._currentVisibleSlidesIndex - 1;\n                }\n            }\n            if (this._chunkedSlides) {\n                this._chunkedSlides[this._currentVisibleSlidesIndex].forEach((slide) => slide.item.active = true);\n            }\n            this.slideRangeChange.emit(this.getVisibleIndexes());\n        }\n    }\n    getVisibleIndexes() {\n        if (!this.singleSlideOffset && this._chunkedSlides) {\n            return this._chunkedSlides[this._currentVisibleSlidesIndex]\n                .map((slide) => slide.index);\n        }\n        if (this._slidesWithIndexes) {\n            return this._slidesWithIndexes.map((slide) => slide.index);\n        }\n    }\n    /**\n     * Sets a slide, which specified through index, as active\n     * @param index\n     */\n    _select(index) {\n        if (isNaN(index)) {\n            this.pause();\n            return;\n        }\n        if (!this.multilist && typeof this._currentActiveSlide !== 'undefined') {\n            const currentSlide = this._slides.get(this._currentActiveSlide);\n            if (typeof currentSlide !== 'undefined') {\n                currentSlide.active = false;\n            }\n        }\n        const nextSlide = this._slides.get(index);\n        if (typeof nextSlide !== 'undefined') {\n            this._currentActiveSlide = index;\n            nextSlide.active = true;\n            this.activeSlide = index;\n            this.activeSlideChange.emit(index);\n        }\n    }\n    /**\n     * Starts loop of auto changing of slides\n     */\n    restartTimer() {\n        this.resetTimer();\n        const interval = +this.interval;\n        if (!isNaN(interval) && interval > 0) {\n            this.currentInterval = this.ngZone.runOutsideAngular(() => {\n                return window.setInterval(() => {\n                    const nInterval = +this.interval;\n                    this.ngZone.run(() => {\n                        if (this.isPlaying &&\n                            !isNaN(this.interval) &&\n                            nInterval > 0 &&\n                            this.slides.length) {\n                            this.nextSlideFromInterval();\n                        }\n                        else {\n                            this.pause();\n                        }\n                    });\n                }, interval);\n            });\n        }\n    }\n    get multilist() {\n        return this.itemsPerSlide > 1;\n    }\n    /**\n     * Stops loop of auto changing of slides\n     */\n    resetTimer() {\n        if (this.currentInterval) {\n            clearInterval(this.currentInterval);\n            this.currentInterval = void 0;\n        }\n    }\n    checkDisabledClass(buttonType) {\n        if (buttonType === 'prev') {\n            return (this.activeSlide === 0 && this.noWrap && !this.multilist) || (this.isFirstSlideVisible && this.noWrap && this.multilist);\n        }\n        return (this.isLast(this.activeSlide) && this.noWrap && !this.multilist) || (this.isLastSlideVisible && this.noWrap && this.multilist);\n    }\n}\nCarouselComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselComponent, deps: [{ token: CarouselConfig }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });\nCarouselComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.1.1\", type: CarouselComponent, selector: \"carousel\", inputs: { noWrap: \"noWrap\", noPause: \"noPause\", showIndicators: \"showIndicators\", pauseOnFocus: \"pauseOnFocus\", indicatorsByChunk: \"indicatorsByChunk\", itemsPerSlide: \"itemsPerSlide\", singleSlideOffset: \"singleSlideOffset\", isAnimated: \"isAnimated\", activeSlide: \"activeSlide\", startFromIndex: \"startFromIndex\", interval: \"interval\" }, outputs: { activeSlideChange: \"activeSlideChange\", slideRangeChange: \"slideRangeChange\" }, ngImport: i0, template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"previousSlide()\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\", directives: [{ type: i2.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { type: i2.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }, { type: i2.NgStyle, selector: \"[ngStyle]\", inputs: [\"ngStyle\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'carousel', template: \"<div (mouseenter)=\\\"pause()\\\"\\n     (mouseleave)=\\\"onMouseLeave()\\\"\\n     (mouseup)=\\\"onMouseUp()\\\"\\n     (keydown)=\\\"keydownPress($event)\\\"\\n     (focusin)=\\\"pauseFocusIn()\\\"\\n     (focusout)=\\\"pauseFocusOut()\\\"\\n     [id]=\\\"currentId\\\"\\n     class=\\\"carousel slide\\\" tabindex=\\\"0\\\">\\n  <ng-container *ngIf=\\\"!_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <ol class=\\\"carousel-indicators\\\">\\n      <li *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n          [class.active]=\\\"slide.active === true\\\"\\n          (click)=\\\"selectSlide(i)\\\">\\n      </li>\\n    </ol>\\n  </ng-container>\\n  <ng-container *ngIf=\\\"_bsVer.isBs5 && showIndicators && slides.length > 1\\\">\\n    <div class=\\\"carousel-indicators\\\">\\n      <button\\n        *ngFor=\\\"let slide of indicatorsSlides(); let i = index;\\\"\\n        [class.active]=\\\"slide.active === true\\\"\\n        (click)=\\\"selectSlide(i)\\\"\\n        type=\\\"button\\\"\\n        [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n        [attr.data-bs-slide-to]=\\\"i\\\" aria-current=\\\"true\\\"\\n      >\\n      </button>\\n    </div>\\n  </ng-container>\\n  <div class=\\\"carousel-inner\\\" [ngStyle]=\\\"{'display': multilist ? 'flex' : 'block'}\\\">\\n    <ng-content></ng-content>\\n  </div>\\n  <a class=\\\"left carousel-control carousel-control-prev\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('prev')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"previousSlide()\\\"\\n      tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-prev carousel-control-prev-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span *ngIf=\\\"isBs4\\\" class=\\\"sr-only visually-hidden\\\">Previous</span>\\n  </a>\\n  <a class=\\\"right carousel-control carousel-control-next\\\"\\n     *ngIf=\\\"slides.length > 1\\\"\\n     [class.disabled]=\\\"checkDisabledClass('next')\\\"\\n     [attr.data-bs-target]=\\\"'#'+currentId\\\"\\n     (click)=\\\"nextSlide()\\\"\\n     tabindex=\\\"0\\\" role=\\\"button\\\">\\n    <span class=\\\"icon-next carousel-control-next-icon\\\" aria-hidden=\\\"true\\\"></span>\\n    <span class=\\\"sr-only visually-hidden\\\">Next</span>\\n  </a>\\n</div>\\n\" }]\n        }], ctorParameters: function () { return [{ type: CarouselConfig }, { type: i0.NgZone }]; }, propDecorators: { noWrap: [{\n                type: Input\n            }], noPause: [{\n                type: Input\n            }], showIndicators: [{\n                type: Input\n            }], pauseOnFocus: [{\n                type: Input\n            }], indicatorsByChunk: [{\n                type: Input\n            }], itemsPerSlide: [{\n                type: Input\n            }], singleSlideOffset: [{\n                type: Input\n            }], isAnimated: [{\n                type: Input\n            }], activeSlideChange: [{\n                type: Output\n            }], slideRangeChange: [{\n                type: Output\n            }], activeSlide: [{\n                type: Input\n            }], startFromIndex: [{\n                type: Input\n            }], interval: [{\n                type: Input\n            }] } });\n\nclass SlideComponent {\n    constructor(carousel) {\n        /** Is current slide active */\n        this.active = false;\n        this.itemWidth = '100%';\n        this.order = 0;\n        this.isAnimated = false;\n        /** Wraps element by appropriate CSS classes */\n        this.addClass = true;\n        this.multilist = false;\n        this.carousel = carousel;\n    }\n    /** Fires changes in container collection after adding a new slide instance */\n    ngOnInit() {\n        var _a;\n        this.carousel.addSlide(this);\n        this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n        this.multilist = ((_a = this.carousel) === null || _a === void 0 ? void 0 : _a.itemsPerSlide) > 1;\n    }\n    /** Fires changes in container collection after removing of this slide instance */\n    ngOnDestroy() {\n        this.carousel.removeSlide(this);\n    }\n}\nSlideComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: SlideComponent, deps: [{ token: CarouselComponent }], target: i0.ɵɵFactoryTarget.Component });\nSlideComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.1.1\", type: SlideComponent, selector: \"slide\", inputs: { active: \"active\" }, host: { properties: { \"attr.aria-hidden\": \"!active\", \"class.multilist-margin\": \"multilist\", \"class.active\": \"this.active\", \"style.width\": \"this.itemWidth\", \"style.order\": \"this.order\", \"class.carousel-animation\": \"this.isAnimated\", \"class.item\": \"this.addClass\", \"class.carousel-item\": \"this.addClass\" } }, ngImport: i0, template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `, isInline: true, styles: [\":host.carousel-animation{transition:opacity .6s ease,visibility .6s ease;float:left}:host.carousel-animation.active{opacity:1;visibility:visible}:host.carousel-animation:not(.active){display:block;position:absolute;opacity:0;visibility:hidden}:host.multilist-margin{margin-right:auto}:host.carousel-item{perspective:1000px}\\n\"] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: SlideComponent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'slide',\n                    template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n                    // eslint-disable-next-line @angular-eslint/no-host-metadata-property\n                    host: {\n                        '[attr.aria-hidden]': '!active',\n                        '[class.multilist-margin]': 'multilist'\n                    },\n                    styles: [`\n    :host.carousel-animation {\n       transition: opacity 0.6s ease, visibility 0.6s ease;\n       float: left;\n    }\n    :host.carousel-animation.active {\n      opacity: 1;\n      visibility: visible;\n    }\n    :host.carousel-animation:not(.active) {\n      display: block;\n      position: absolute;\n      opacity: 0;\n      visibility: hidden;\n    }\n    :host.multilist-margin {\n      margin-right: auto;\n    }\n    :host.carousel-item {\n      perspective: 1000px;\n    }\n  `]\n                }]\n        }], ctorParameters: function () { return [{ type: CarouselComponent }]; }, propDecorators: { active: [{\n                type: HostBinding,\n                args: ['class.active']\n            }, {\n                type: Input\n            }], itemWidth: [{\n                type: HostBinding,\n                args: ['style.width']\n            }], order: [{\n                type: HostBinding,\n                args: ['style.order']\n            }], isAnimated: [{\n                type: HostBinding,\n                args: ['class.carousel-animation']\n            }], addClass: [{\n                type: HostBinding,\n                args: ['class.item']\n            }, {\n                type: HostBinding,\n                args: ['class.carousel-item']\n            }] } });\n\nclass CarouselModule {\n    static forRoot() {\n        return { ngModule: CarouselModule, providers: [] };\n    }\n}\nCarouselModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nCarouselModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, declarations: [SlideComponent, CarouselComponent], imports: [CommonModule], exports: [SlideComponent, CarouselComponent] });\nCarouselModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, imports: [[CommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.1\", ngImport: i0, type: CarouselModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule],\n                    declarations: [SlideComponent, CarouselComponent],\n                    exports: [SlideComponent, CarouselComponent]\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CarouselComponent, CarouselConfig, CarouselModule, SlideComponent };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}